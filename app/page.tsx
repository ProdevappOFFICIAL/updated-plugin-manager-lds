'use client'

import React, { useState, useEffect, useCallback } from 'react'
import { Upload, Download, FileText, Settings, Eye, Save, Trash2, RefreshCw, MapPin, AlertCircle, CheckCircle, X, Grid, Table } from 'lucide-react'
import mammoth from 'mammoth'
import JSZip from 'jszip'
import { saveAs } from 'file-saver'

// Add custom CSS for animations
const customStyles = `
  @keyframes fade-in {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @keyframes slide-down {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  @keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
    50% { box-shadow: 0 0 0 8px rgba(59, 130, 246, 0); }
  }
  
  .animate-fade-in {
    animation: fade-in 0.6s ease-out;
  }
  
  .animate-slide-down {
    animation: slide-down 0.4s ease-out;
  }
  
  .animate-pulse-glow {
    animation: pulse-glow 2s infinite;
  }
`

// Inject styles
if (typeof document !== 'undefined') {
  const styleSheet = document.createElement('style')
  styleSheet.textContent = customStyles
  document.head.appendChild(styleSheet)
}

interface SubjectScore {
  correct: number
  total: number
}

interface StudentResult {
  username: string
  studentId?: string // Will be user_email from API
  className?: string // Will be classname from API
  img?: string
  subjectScores: Record<string, SubjectScore>
  examTermScores?: Record<string, SubjectScore> // New: for different exam terms
  examResults?: ExamResult[] // Multiple exam results for the same student
  percentage?: number
  position?: number
  grade?: string
  remark?: string
  manualScores?: Record<string, number> // For manual input scores
  // CT and Exam specific scores for computation
  ctScores?: Record<string, SubjectScore> // CT test scores by subject
  examScores?: Record<string, SubjectScore> // Exam scores by subject
  totalScores?: Record<string, number> // Computed total scores (CT + Exam)
  // Original fields from API for compatibility
  exam_name?: string
  classname?: string
  user_email?: string // Original user email from API
  created_at?: string
}

interface ExamResult {
  examId: string
  examName: string
  examType: 'CT' | 'EXAM' | 'ASSIGNMENT' | 'PROJECT'
  subjectScores: Record<string, SubjectScore>
  date?: string
  term?: string
  session?: string
}

interface TemplateMapping {
  subject: string
  cellId: string
  format: 'percentage' | 'raw' | 'grade' | 'total' | 'calculated' | 'manual_input' | 'student_id' | 'class_name' | 'student_name' | 'ct_score' | 'exam_score' | 'ct_exam_total'
  examId?: string // Specific exam ID to use
  examName?: string // Specific exam name to use
  examType?: 'CT' | 'EXAM' | 'ASSIGNMENT' | 'PROJECT'
  examTerm?: string // e.g., 'first_term', 'second_term', 'third_term'
  calculationType?: 'sum' | 'average' | 'ct_exam_total' // enhanced calculation types
  calculationSources?: string[] // cell IDs or exam IDs to calculate from
  isManualInput?: boolean // For cells that need manual input
  tableName?: string
  tableIndex?: number
  rowIndex?: number
  cellIndex?: number
}

interface Template {
  id: string
  name: string
  file: File | null
  fileName: string
  mappings: TemplateMapping[]
  createdAt: string
  previewData?: any
  originalDocxBuffer?: ArrayBuffer // Store original DOCX for manipulation
}

export default function ResultAutomation() {
  const [results, setResults] = useState<StudentResult[]>([])
  const [templates, setTemplates] = useState<Template[]>([])
  const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [success, setSuccess] = useState<string | null>(null)
  const [currentStep, setCurrentStep] = useState<'upload' | 'exam_selection' | 'mapping' | 'preview' | 'export'>('upload')
  const [availableSubjects, setAvailableSubjects] = useState<string[]>([])
  const [availableExams, setAvailableExams] = useState<ExamResult[]>([])
  const [selectedExams, setSelectedExams] = useState<string[]>([])
  const [manualScores, setManualScores] = useState<Record<string, Record<string, number>>>({})
  const [manualCTScores, setManualCTScores] = useState<Record<string, Record<string, number>>>({})
  const [manualExamScores, setManualExamScores] = useState<Record<string, Record<string, number>>>({})
  const [manualInputs, setManualInputs] = useState<Record<string, Record<string, number>>>({})
  const [autoGeneratedIds, setAutoGeneratedIds] = useState<Record<string, string>>({})
  const [classNames, setClassNames] = useState<Record<string, string>>({})
  
  // Template creation states
  const [templateName, setTemplateName] = useState('')
  const [uploadedFile, setUploadedFile] = useState<File | null>(null)
  const [mappings, setMappings] = useState<TemplateMapping[]>([])
  const [showMappingModal, setShowMappingModal] = useState(false)
  const [currentMapping, setCurrentMapping] = useState<Partial<TemplateMapping>>({})
  
  // DOCX preview states
  const [docxPreview, setDocxPreview] = useState<any>(null)
  const [selectedCell, setSelectedCell] = useState<string | null>(null)
  const [tableStructure, setTableStructure] = useState<any[]>([])

  // Parse DOCX file for preview and mapping using enhanced parsing
  const parseDocxFile = async (file: File) => {
    try {
      setLoading(true)
      
      // Read file as array buffer
      const arrayBuffer = await file.arrayBuffer()
      
      // Method 1: Direct XML parsing for better table detection
      let tableStructure: any[] = []
      
      try {
        const zip = new JSZip()
        const docxZip = await zip.loadAsync(arrayBuffer)
        const documentXml = await docxZip.file('word/document.xml')?.async('string')
        
        if (documentXml) {
          console.log('Parsing DOCX XML directly...')
          
          // Parse XML to extract table structure
          const parser = new DOMParser()
          const xmlDoc = parser.parseFromString(documentXml, 'text/xml')
          
          // Find all table elements - try multiple selectors for compatibility
          const xmlTables = xmlDoc.querySelectorAll('w\\:tbl') || xmlDoc.querySelectorAll('tbl')
          console.log(`Found ${xmlTables.length} tables in XML`)
          
          Array.from(xmlTables).forEach((xmlTable, tableIndex) => {
            const rows: any[] = []
            const xmlRows = xmlTable.querySelectorAll('w\\:tr') || xmlTable.querySelectorAll('tr')
            console.log(`Table ${tableIndex}: Found ${xmlRows.length} rows`)
            
            Array.from(xmlRows).forEach((xmlRow, rowIndex) => {
              const cells: any[] = []
              const xmlCells = xmlRow.querySelectorAll('w\\:tc') || xmlRow.querySelectorAll('tc')
              
              Array.from(xmlCells).forEach((xmlCell, cellIndex) => {
                // Extract text content from all text nodes in the cell
                const textNodes = xmlCell.querySelectorAll('w\\:t') || xmlCell.querySelectorAll('t')
                let content = ''
                Array.from(textNodes).forEach(textNode => {
                  content += textNode.textContent || ''
                })
                
                content = content.trim()
                
                // More lenient empty cell detection
                const isEmpty = content === '' || content.length === 0 || /^\s*$/.test(content) || content === '\u00A0'
                const isHeader = rowIndex === 0 || content.toLowerCase().includes('subject') || content.toLowerCase().includes('name')
                
                cells.push({
                  id: `cell-${tableIndex}-${rowIndex}-${cellIndex}`,
                  content: content || '[Empty]',
                  type: isHeader ? 'header' : 'data',
                  mappable: !isHeader && isEmpty,
                  tableIndex,
                  rowIndex,
                  cellIndex,
                  isEmpty
                })
              })
              
              if (cells.length > 0) {
                rows.push({
                  id: `row-${tableIndex}-${rowIndex}`,
                  index: rowIndex,
                  cells
                })
              }
            })
            
            if (rows.length > 0) {
              tableStructure.push({
                id: `table-${tableIndex}`,
                name: `Table ${tableIndex + 1}`,
                index: tableIndex,
                rows
              })
            }
          })
        }
      } catch (xmlError) {
        console.warn('XML parsing failed, falling back to mammoth:', xmlError)
      }
      
      // Method 2: Fallback to mammoth if XML parsing fails or finds no tables
      if (tableStructure.length === 0) {
        console.log('Falling back to mammoth parsing...')
        
        const result = await mammoth.convertToHtml({ arrayBuffer })
        const htmlContent = result.value
        console.log('Mammoth HTML output:', htmlContent.substring(0, 500))
        
        // Parse HTML to extract table structure
        const parser = new DOMParser()
        const doc = parser.parseFromString(htmlContent, 'text/html')
        const tables = doc.querySelectorAll('table')
        console.log(`Mammoth found ${tables.length} tables`)
        
        tableStructure = Array.from(tables).map((table, tableIndex) => {
          const rows = Array.from(table.querySelectorAll('tr'))
          
          return {
            id: `table-${tableIndex}`,
            name: `Table ${tableIndex + 1}`,
            index: tableIndex,
            rows: rows.map((row, rowIndex) => {
              const cells = Array.from(row.querySelectorAll('td, th'))
              
              return {
                id: `row-${tableIndex}-${rowIndex}`,
                index: rowIndex,
                cells: cells.map((cell, cellIndex) => {
                  const content = cell.textContent?.trim() || ''
                  const isHeader = cell.tagName.toLowerCase() === 'th' || rowIndex === 0
                  const isEmpty = !content || content === '' || content === ' ' || content === '\u00A0'
                  
                  return {
                    id: `cell-${tableIndex}-${rowIndex}-${cellIndex}`,
                    content: content || '[Empty]',
                    type: isHeader ? 'header' : 'data',
                    mappable: !isHeader && isEmpty,
                    tableIndex,
                    rowIndex,
                    cellIndex,
                    isEmpty,
                    originalElement: cell
                  }
                })
              }
            })
          }
        })
      }
      
      console.log('Final table structure:', tableStructure)
      
      // Store original DOCX buffer for later manipulation
      const templateData = {
        fileName: file.name,
        tables: tableStructure,
        hasContent: tableStructure.length > 0,
        originalBuffer: arrayBuffer,
        totalTables: tableStructure.length,
        totalMappableCells: tableStructure.reduce((total, table) => 
          total + table.rows.reduce((rowTotal: number, row: any) => 
            rowTotal + row.cells.filter((cell: any) => cell.mappable).length, 0), 0)
      }
      
      setTableStructure(tableStructure)
      setDocxPreview(templateData)
      
      return templateData
    } catch (err) {
      console.error('Error parsing DOCX:', err)
      setError('Failed to parse DOCX file. Please ensure it contains valid tables.')
      return null
    } finally {
      setLoading(false)
    }
  }

  // Fetch results from API with enhanced exam term support
  const fetchResults = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      
      const response = await fetch('http://localhost:80/api/Result', {
        headers: {
          authorization: '4000'
        }
      })
      if (!response.ok) {
        throw new Error(`Failed to fetch results: ${response.status}`)
      }
      
      const data = await response.json()
      const rawResults = data.Result || data || []
      
      // Process and validate the data with enhanced exam support
      const processedResults: StudentResult[] = rawResults.map((result: any, index: number) => {
        // Use actual user_email as student ID (not auto-generated)
        const studentId = result.user_email || result.studentId || `STD${String(index + 1).padStart(4, '0')}`
        
        // Use actual classname from API data (not auto-filled)
        const className = result.classname || result.className || result.class || 'JSS1A'
        
        // Calculate percentage and other metrics like in result.jsx
        const questionsAttempted = result.subjectScores
          ? Object.values(result.subjectScores).reduce((sum: number, score: any) => sum + (score.total || 0), 0)
          : 0
        const totalCorrect = result.subjectScores
          ? Object.values(result.subjectScores).reduce((sum: number, score: any) => sum + (score.correct || 0), 0)
          : 0
        const percentage = questionsAttempted > 0 ? Math.round((totalCorrect / questionsAttempted) * 100) : 0
        
        // Initialize CT and Exam scores (will be populated manually)
        const ctScores: Record<string, SubjectScore> = {}
        const examScores: Record<string, SubjectScore> = {}
        const totalScores: Record<string, number> = {}
        
        // Initialize with empty scores for each subject
        if (result.subjectScores) {
          Object.keys(result.subjectScores).forEach(subject => {
            ctScores[subject] = { correct: 0, total: 0 }
            examScores[subject] = { correct: 0, total: 0 }
            totalScores[subject] = 0
          })
        }
        
        return {
          username: result.username || 'Unknown Student',
          studentId, // This will be user_email from API
          className, // This will be classname from API
          img: result.img,
          subjectScores: result.subjectScores || {},
          examTermScores: result.examTermScores || {},
          examResults: [], // Will be populated from exam_name
          percentage: result.percentage || percentage,
          position: result.position,
          grade: result.grade,
          remark: result.remark,
          manualScores: {},
          ctScores,
          examScores,
          totalScores,
          // Keep original fields for compatibility
          exam_name: result.exam_name,
          classname: result.classname,
          user_email: result.user_email, // Keep original user_email
          created_at: result.created_at || new Date().toISOString()
        }
      })
      
      setResults(processedResults)
      
      // Extract available subjects and exams from the actual data structure
      const subjects = new Set<string>()
      const examNames = new Set<string>()
      const exams: ExamResult[] = []
      
      processedResults.forEach(result => {
        // Extract subjects from subjectScores
        if (result.subjectScores) {
          Object.keys(result.subjectScores).forEach(subject => {
            subjects.add(subject)
          })
        }
        
        // Extract exam names
        if (result.exam_name) {
          examNames.add(result.exam_name)
        }
      })
      
      // Create exam objects from unique exam names
      Array.from(examNames).forEach((examName, index) => {
        exams.push({
          examId: `exam_${index + 1}`,
          examName: examName,
          examType: 'EXAM', // Default type, can be enhanced later
          subjectScores: {},
          date: new Date().toISOString(),
          term: '',
          session: ''
        })
      })
      
      setAvailableSubjects(Array.from(subjects).sort())
      setAvailableExams(exams)
      
      // Initialize actual IDs and class names from API data
      const ids: Record<string, string> = {}
      const classes: Record<string, string> = {}
      processedResults.forEach(result => {
        ids[result.username] = result.studentId! // This is now user_email
        classes[result.username] = result.className! // This is now actual classname
      })
      setAutoGeneratedIds(ids)
      setClassNames(classes)
      
      setSuccess(`Loaded ${processedResults.length} student results with ${exams.length} different exams`)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch results')
    } finally {
      setLoading(false)
    }
  }, [])

  // Load templates from localStorage
  useEffect(() => {
    const savedTemplates = localStorage.getItem('resultTemplates')
    if (savedTemplates) {
      try {
        const parsed = JSON.parse(savedTemplates)
        setTemplates(parsed)
      } catch (err) {
        console.error('Failed to load templates:', err)
      }
    }
  }, [])

  // Auto-fetch results on component mount
  useEffect(() => {
    fetchResults()
  }, [])

  // Save templates to localStorage
  const saveTemplates = useCallback((newTemplates: Template[]) => {
    localStorage.setItem('resultTemplates', JSON.stringify(newTemplates))
    setTemplates(newTemplates)
  }, [])

  // Handle file upload
  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file && file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
      setUploadedFile(file)
      setError(null)
      
      // Parse the DOCX file to extract table structure
      setLoading(true)
      try {
        await parseDocxFile(file)
        setSuccess('DOCX file uploaded and parsed successfully')
      } catch (err) {
        setError('Failed to parse DOCX file')
      } finally {
        setLoading(false)
      }
    } else {
      setError('Please upload a valid DOCX file')
    }
  }

  // Create new template
  const createTemplate = () => {
    if (!templateName.trim() || !uploadedFile || !docxPreview) {
      setError('Please provide a template name and upload a valid DOCX file')
      return
    }

    const newTemplate: Template = {
      id: Date.now().toString(),
      name: templateName.trim(),
      file: uploadedFile,
      fileName: uploadedFile.name,
      mappings: [],
      createdAt: new Date().toISOString(),
      previewData: docxPreview,
      originalDocxBuffer: docxPreview.originalBuffer
    }

    const updatedTemplates = [...templates, newTemplate]
    saveTemplates(updatedTemplates)
    setSelectedTemplate(newTemplate)
    setCurrentStep('exam_selection')
    setSuccess(`Template "${templateName}" created successfully`)
    
    // Reset form
    setTemplateName('')
    setUploadedFile(null)
  }

  // Handle cell selection for mapping
  const handleCellClick = (cellId: string, tableName?: string, tableIndex?: number, rowIndex?: number, cellIndex?: number) => {
    if (selectedCell === cellId) {
      setSelectedCell(null)
      return
    }
    
    setSelectedCell(cellId)
    setCurrentMapping({
      ...currentMapping,
      cellId,
      tableName,
      tableIndex,
      rowIndex,
      cellIndex
    })
    setShowMappingModal(true)
  }

  // Add subject mapping with enhanced options
  const addMapping = () => {
    if (!currentMapping.cellId || !currentMapping.format) {
      setError('Please select a data type and ensure a cell is selected')
      return
    }

    // Only require subject for subject-related formats
    const subjectRequiredFormats = ['percentage', 'raw', 'total', 'grade', 'calculated', 'manual_input', 'ct_score', 'exam_score', 'ct_exam_total']
    if (subjectRequiredFormats.includes(currentMapping.format!) && !currentMapping.subject) {
      setError('Please select a subject for this data type')
      return
    }

    // Check if cell is already mapped
    const existingMapping = mappings.find(m => m.cellId === currentMapping.cellId)
    if (existingMapping) {
      setError('This cell is already mapped to another data type')
      return
    }

    const newMapping: TemplateMapping = {
      subject: currentMapping.subject || '', // Empty string for non-subject formats
      cellId: currentMapping.cellId!,
      format: currentMapping.format!,
      examId: currentMapping.examId,
      examName: currentMapping.examName,
      examType: currentMapping.examType,
      examTerm: currentMapping.examTerm,
      calculationType: currentMapping.calculationType,
      calculationSources: currentMapping.calculationSources,
      tableName: currentMapping.tableName,
      tableIndex: currentMapping.tableIndex,
      rowIndex: currentMapping.rowIndex,
      cellIndex: currentMapping.cellIndex
    }

    setMappings([...mappings, newMapping])
    setCurrentMapping({})
    setShowMappingModal(false)
    setSelectedCell(null)
    setError(null)
    
    let successMessage = `Mapped ${newMapping.format} to selected cell`
    if (newMapping.subject) {
      successMessage = `Mapped ${newMapping.subject} (${newMapping.format}) to selected cell`
    }
    if (newMapping.examTerm) {
      successMessage += ` (${newMapping.examTerm.replace('_', ' ')})`
    }
    if (newMapping.calculationType) {
      successMessage += ` (${newMapping.calculationType})`
    }
    
    setSuccess(successMessage)
  }

  // Save mappings to template
  const saveMappings = () => {
    if (!selectedTemplate) return

    const updatedTemplate = {
      ...selectedTemplate,
      mappings: mappings
    }

    const updatedTemplates = templates.map(t => 
      t.id === selectedTemplate.id ? updatedTemplate : t
    )

    saveTemplates(updatedTemplates)
    setSelectedTemplate(updatedTemplate)
    setCurrentStep('preview')
    setSuccess('Mappings saved successfully')
  }

  // Delete template
  const deleteTemplate = (templateId: string) => {
    const updatedTemplates = templates.filter(t => t.id !== templateId)
    saveTemplates(updatedTemplates)
    
    if (selectedTemplate?.id === templateId) {
      setSelectedTemplate(null)
      setCurrentStep('upload')
    }
    
    setSuccess('Template deleted successfully')
  }

  // Helper function to calculate CT + Exam total for display
  const calculateCTExamTotal = (studentName: string, subject: string): number => {
    const ctKey = `${studentName}_${subject}`
    const examKey = `${studentName}_${subject}`
    const ctScore = manualCTScores[ctKey]?.[subject] || 0
    const examScore = manualExamScores[examKey]?.[subject] || 0
    return ctScore + examScore
  }

  // Enhanced data processing function with CT/Exam computation
  const getStudentValue = (student: StudentResult, mapping: TemplateMapping): string => {
    const { format, subject, examId, examName, calculationType, calculationSources } = mapping
    
    // Handle auto-generated fields
    if (format === 'student_name') {
      return student.username || 'Unknown Student'
    }
    
    if (format === 'student_id') {
      return student.studentId || student.user_email || autoGeneratedIds[student.username] || 'N/A'
    }
    
    if (format === 'class_name') {
      return "CLASS: " + student.className || "CLASS: " + student.classname || "CLASS: " + classNames[student.username] || 'N/A'
    }
    
    // Handle CT scores (manual input)
    if (format === 'ct_score' && subject) {
      const ctKey = `${student.username}_${subject}`
      return manualCTScores[ctKey]?.[subject]?.toString() || ''
    }
    
    // Handle Exam scores (manual input)
    if (format === 'exam_score' && subject) {
      const examKey = `${student.username}_${subject}`
      return manualExamScores[examKey]?.[subject]?.toString() || ''
    }
    
    // Handle CT + Exam Total computation
    if (format === 'ct_exam_total' && subject) {
      const ctKey = `${student.username}_${subject}`
      const examKey = `${student.username}_${subject}`
      const ctScore = manualCTScores[ctKey]?.[subject] || 0
      const examScore = manualExamScores[examKey]?.[subject] || 0
      return (ctScore + examScore).toString()
    }
    
    // Handle manual input fields (for other manual entries)
    if (format === 'manual_input') {
      const manualKey = `${student.username}_${subject}`
      return manualScores[manualKey]?.[subject]?.toString() || ''
    }
    
    // Handle calculated fields with enhanced CT + Exam + Total logic
    if (format === 'calculated' && calculationType) {
      if (calculationType === 'ct_exam_total') {
        // Auto-calculate CT + Exam + Total for the subject
        const ctKey = `${student.username}_${subject}`
        const examKey = `${student.username}_${subject}`
        const ctScore = manualCTScores[ctKey]?.[subject] || 0
        const examScore = manualExamScores[examKey]?.[subject] || 0
        return (ctScore + examScore).toString()
      } else if (calculationSources && calculationSources.length > 0) {
        // Calculate from selected sources (exam names)
        let calculatedValue = 0
        let validSources = 0
        
        calculationSources.forEach(sourceExamName => {
          // Check if this student has results for this exam
          if (student.exam_name === sourceExamName && subject) {
            const score = student.subjectScores[subject]
            if (score) {
              calculatedValue += score.correct
              validSources++
            }
          }
        })
        
        if (validSources > 0) {
          if (calculationType === 'average') {
            calculatedValue = Math.round(calculatedValue / validSources)
          }
          return calculatedValue.toString()
        }
      }
      return '0'
    }
    
    // Handle specific exam scores by exam name
    if (examName && subject) {
      // Only use this student's data if their exam matches the selected exam
      if (student.exam_name === examName) {
        const score = student.subjectScores[subject]
        if (score) {
          return formatScore(score, format!)
        }
      }
      return '-' // Student doesn't have data for this exam
    }
    
    // Handle regular subject scores (use current student's data regardless of exam)
    if (subject) {
      const score = student.subjectScores[subject]
      if (score) {
        return formatScore(score, format!)
      }
    }
    
    return '-'
  }
  
  // Helper function to format scores
  const formatScore = (score: SubjectScore, format: string): string => {
    switch (format) {
      case 'percentage':
        return `${Math.round((score.correct / score.total) * 100)}%`
      case 'raw':
        return `${score.correct}/${score.total}`
      case 'total':
        return score.correct.toString()
      case 'grade':
        const percentage = Math.round((score.correct / score.total) * 100)
        return percentage >= 80 ? 'A' : percentage >= 70 ? 'B' : percentage >= 60 ? 'C' : percentage >= 50 ? 'D' : 'F'
      default:
        return score.correct.toString()
    }
  }

  // Generate actual DOCX file with filled data - one file per student with merged exam data
  const generateDocument = async () => {
    if (!selectedTemplate || !results.length || !selectedTemplate.originalDocxBuffer) {
      setError('No template selected, no results available, or original DOCX buffer missing')
      return
    }

    try {
      setLoading(true)
      
      // Group results by student to merge multiple exam results
      const studentGroups = new Map<string, StudentResult[]>()
      
      results.forEach(result => {
        const studentKey = result.username || result.user_email || 'Unknown'
        if (!studentGroups.has(studentKey)) {
          studentGroups.set(studentKey, [])
        }
        studentGroups.get(studentKey)!.push(result)
      })
      
      console.log(`Processing ${studentGroups.size} unique students from ${results.length} result records`)
      
      // Load the original DOCX file
      const zip = new JSZip()
      const docxZip = await zip.loadAsync(selectedTemplate.originalDocxBuffer)
      
      // Get the document.xml file (main content)
      const documentXml = await docxZip.file('word/document.xml')?.async('string')
      if (!documentXml) {
        throw new Error('Could not find document.xml in DOCX file')
      }
      
      // Parse the XML
      const parser = new DOMParser()
      const xmlDoc = parser.parseFromString(documentXml, 'text/xml')
      
      // Process each unique student and create one document per student
      for (const [studentName, studentResults] of Array.from(studentGroups)) {
        // Merge all exam results for this student
        const mergedStudent = mergeStudentResults(studentResults)
        
        // Clone the original XML for this student
        const studentXmlDoc = xmlDoc.cloneNode(true) as Document
        const studentTables = studentXmlDoc.querySelectorAll('w\\:tbl, tbl')
        
        // Apply mappings for this student with merged data
        selectedTemplate.mappings.forEach(mapping => {
          const { tableIndex, rowIndex, cellIndex } = mapping
          
          if (tableIndex !== undefined && rowIndex !== undefined && cellIndex !== undefined) {
            const targetTable = studentTables[tableIndex]
            if (targetTable) {
              const rows = targetTable.querySelectorAll('w\\:tr, tr')
              const targetRow = rows[rowIndex]
              if (targetRow) {
                const cells = targetRow.querySelectorAll('w\\:tc, tc')
                const targetCell = cells[cellIndex]
                if (targetCell) {
                  const value = getStudentValueMerged(mergedStudent, studentResults, mapping)
                  
                  // Find the text element and replace its content
                  const textElements = targetCell.querySelectorAll('w\\:t, t')
                  if (textElements.length > 0) {
                    textElements[0].textContent = value
                    // Clear other text elements in the same cell
                    for (let i = 1; i < textElements.length; i++) {
                      textElements[i].textContent = ''
                    }
                  } else {
                    // Create new text element if none exists
                    const paragraph = targetCell.querySelector('w\\:p, p')
                    if (paragraph) {
                      const run = studentXmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:r')
                      const text = studentXmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:t')
                      text.textContent = value
                      run.appendChild(text)
                      paragraph.appendChild(run)
                    }
                  }
                }
              }
            }
          }
        })
        
        // Serialize the modified XML
        const serializer = new XMLSerializer()
        const modifiedDocumentXml = serializer.serializeToString(studentXmlDoc)
        
        // Create new DOCX file for this student
        const newZip = new JSZip()
        
        // Copy all files from original DOCX
        await Promise.all(Object.keys(docxZip.files).map(async (filename) => {
          const file = docxZip.files[filename]
          if (filename === 'word/document.xml') {
            // Use our modified document.xml
            newZip.file(filename, modifiedDocumentXml)
          } else if (!file.dir) {
            // Copy other files as-is
            const content = await file.async('arraybuffer')
            newZip.file(filename, content)
          }
        }))
        
        // Generate the new DOCX file
        const newDocxBuffer = await newZip.generateAsync({ type: 'blob' })
        
        // Download the file - one per student
        const fileName = `${selectedTemplate.name}_${studentName.replace(/[^a-zA-Z0-9]/g, '_')}.docx`
        saveAs(newDocxBuffer, fileName)
      }
      
      setSuccess(`Generated ${studentGroups.size} DOCX files (one per student) from ${results.length} result records!`)
      
    } catch (err) {
      console.error('Error generating DOCX:', err)
      setError(`Failed to generate DOCX files: ${err instanceof Error ? err.message : 'Unknown error'}`)
    } finally {
      setLoading(false)
    }
  }

  // Helper function to merge multiple exam results for the same student
  const mergeStudentResults = (studentResults: StudentResult[]): StudentResult => {
    if (studentResults.length === 1) {
      return studentResults[0]
    }

    // Use the first result as base and merge others
    const baseResult = { ...studentResults[0] }
    
    // Merge subject scores from all exams
    const mergedSubjectScores: Record<string, SubjectScore> = { ...baseResult.subjectScores }
    
    // Collect all exam names this student participated in
    const examNames: string[] = baseResult.exam_name ? [baseResult.exam_name] : []
    
    studentResults.slice(1).forEach(result => {
      // Add exam name to the list
      if (result.exam_name && !examNames.includes(result.exam_name)) {
        examNames.push(result.exam_name)
      }
      
      // Merge subject scores from this exam
      if (result.subjectScores) {
        Object.entries(result.subjectScores).forEach(([subject, score]) => {
          // Create unique keys for subjects from different exams
          const subjectKey = `${subject}(${result.exam_name || 'Unknown Exam'})`
          mergedSubjectScores[subjectKey] = score
          
          // Also keep the original subject key for backward compatibility
          if (!mergedSubjectScores[subject]) {
            mergedSubjectScores[subject] = score
          }
        })
      }
    })
    
    // Update the merged result
    baseResult.subjectScores = mergedSubjectScores
    baseResult.exam_name = examNames.join(', ') // Combine all exam names
    
    return baseResult
  }

  // Enhanced getStudentValue function that handles merged student data
  const getStudentValueMerged = (mergedStudent: StudentResult, allStudentResults: StudentResult[], mapping: TemplateMapping): string => {
    const { format, subject, examName, calculationType, calculationSources } = mapping
    
    // Handle basic student info
    if (format === 'student_name') {
      return mergedStudent.username || 'Unknown Student'
    }
    
    if (format === 'student_id') {
      return mergedStudent.studentId || mergedStudent.user_email || 'N/A'
    }
    
    if (format === 'class_name') {
      return "CLASS: " + mergedStudent.className || "CLASS: " + mergedStudent.classname || 'N/A'
    }
    
    // Handle CT scores (manual input)
    if (format === 'ct_score' && subject) {
      const ctKey = `${mergedStudent.username}_${subject}`
      return manualCTScores[ctKey]?.[subject]?.toString() || ''
    }
    
    // Handle Exam scores (manual input)
    if (format === 'exam_score' && subject) {
      const examKey = `${mergedStudent.username}_${subject}`
      return manualExamScores[examKey]?.[subject]?.toString() || ''
    }
    
    // Handle CT + Exam Total computation
    if (format === 'ct_exam_total' && subject) {
      const ctKey = `${mergedStudent.username}_${subject}`
      const examKey = `${mergedStudent.username}_${subject}`
      const ctScore = manualCTScores[ctKey]?.[subject] || 0
      const examScore = manualExamScores[examKey]?.[subject] || 0
      return (ctScore + examScore).toString()
    }
    
    // Handle manual input fields (for other manual entries)
    if (format === 'manual_input' && subject) {
      const manualKey = `${mergedStudent.username}_${subject}`
      return manualInputs[manualKey]?.[subject]?.toString() || ''
    }
    
    // Handle calculated values (sum/average of multiple subjects)
    if (format === 'calculated' && calculationSources?.length) {
      let calculatedValue = 0
      let validSources = 0
      
      calculationSources.forEach(sourceSubject => {
        // Check if this is an exam-specific subject
        const subjectKey = examName ? `${sourceSubject}(${examName})` : sourceSubject
        const score = mergedStudent.subjectScores[subjectKey] || mergedStudent.subjectScores[sourceSubject]
        
        if (score) {
          calculatedValue += score.correct
          validSources++
        }
      })
      
      if (validSources > 0) {
        if (calculationType === 'average') {
          calculatedValue = Math.round(calculatedValue / validSources)
        }
        return calculatedValue.toString()
      }
      return '0'
    }
    
    // Handle specific exam scores by exam name
    if (examName && subject) {
      // Look for exam-specific subject key first
      const examSubjectKey = `${subject}(${examName})`
      let score = mergedStudent.subjectScores[examSubjectKey]
      
      // If not found, check if any of the original results match this exam
      if (!score) {
        const matchingResult = allStudentResults.find(r => r.exam_name === examName)
        if (matchingResult && matchingResult.subjectScores[subject]) {
          score = matchingResult.subjectScores[subject]
        }
      }
      
      if (score) {
        return formatScore(score, format!)
      }
      return '-' // Student doesn't have data for this exam
    }
    
    // Handle regular subject scores (use any available data)
    if (subject) {
      const score = mergedStudent.subjectScores[subject]
      if (score) {
        return formatScore(score, format!)
      }
    }
    
    return '-'
  }

  // Generate CSV with mapping information
  const generateMappedCSV = (): string => {
    if (!selectedTemplate || !results.length) return ''

    const headers = ['Student Name']
    const mappingHeaders: string[] = []
    
    // Add headers based on mappings
    selectedTemplate.mappings.forEach(mapping => {
      headers.push(`${mapping.subject} (${mapping.format}) [Cell: ${mapping.cellId}]`)
      mappingHeaders.push(`${mapping.subject}_${mapping.format}`)
    })

    const rows = results.map(result => {
      const row = [result.username]
      
      selectedTemplate.mappings.forEach(mapping => {
        const score = result.subjectScores[mapping.subject]
        if (score) {
          switch (mapping.format) {
            case 'percentage':
              row.push(`${Math.round((score.correct / score.total) * 100)}%`)
              break
            case 'raw':
              row.push(`${score.correct}/${score.total}`)
              break
            case 'total':
              row.push(score.correct.toString())
              break
            case 'grade':
              const percentage = Math.round((score.correct / score.total) * 100)
              const grade = percentage >= 80 ? 'A' : percentage >= 70 ? 'B' : percentage >= 60 ? 'C' : percentage >= 50 ? 'D' : 'F'
              row.push(grade)
              break
            default:
              row.push('-')
          }
        } else {
          row.push('-')
        }
      })
      
      return row
    })

    // Add mapping information at the top
    const mappingInfo = [
      ['# Template Mapping Information'],
      ['# Template:', selectedTemplate.name],
      ['# File:', selectedTemplate.fileName],
      ['# Mappings:'],
      ...selectedTemplate.mappings.map(m => [`# ${m.subject} -> Cell ${m.cellId} (${m.format})`]),
      [''],
      headers,
      ...rows
    ]

    return mappingInfo.map(row => row.join(',')).join('\n')
  }

  // Clear messages
  const clearMessages = () => {
    setError(null)
    setSuccess(null)
  }

  return (
    <div className="min-h-screen text-[10px] ">
        {(error || success) && (
          <div className=" animate-slide-down">
            {error && (
                <div className="bg-red-500 text-white px-1 py-[2px] flex items-center justify-between backdrop-blur-sm">
                <div className="flex items-center gap-3">
               
                    <AlertCircle className="w-4 h-4" />
                
                  <span className=" font-medium">{error}</span>
                </div>
                <button 
                  onClick={clearMessages} 
                  className=" hover:text-red-600 transition-colors duration-200 p-1 rounded-full hover:bg-red-100"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
            )}
            {success && (
              <div className="bg-green-500 text-white px-1 py-[2px] flex items-center justify-between backdrop-blur-sm">
                <div className="flex items-center gap-3">
                 
                    <CheckCircle className="w-4 h-4" />
              
                  <span className="font-medium">{success}</span>
                </div>
                <button 
                  onClick={clearMessages} 
                  className ="transition-colors duration-200 p-1 rounded-full hover:bg-green-100"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
            )}
          </div>
        )}

      <div className="p-4">
        <div className="animate-fade-in">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="font-bold">
                LearningDeck Result Manager
              </h1>
              <p className="text-slate-600 mt-2 ">Automate result generation using custom DOCX templates</p>
            </div>
            <button
              onClick={fetchResults}
              disabled={loading}
              className="hidden flex items-center gap-3 px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 transition-all duration-300 transform hover:scale-105 active:scale-95"
            >
              <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
              <span className="font-medium">Fetch Results</span>
            </button>
          </div>
        </div>

      

      
   

        <div className="flex w-full space-x-2 p-4">
            {/* Step Navigation */}
          
           <div className="animate-fade-in">
  <div className="flex flex-col space-y-4">
    {['upload', 'exam_selection', 'mapping', 'preview', 'export'].map((step, index) => (
      <div key={step} className="flex items-start">
        <div className="flex flex-col items-center">
          <div className={`w-4 h-4 rounded-full flex items-center justify-center font-bold transition-all duration-300 ${
            currentStep === step 
              ? 'bg-gradient-to-r from-blue-500 to-blue-600 text-white scale-110' 
              : index < ['upload', 'exam_selection', 'mapping', 'preview', 'export'].indexOf(currentStep)
                ? 'bg-gradient-to-r from-green-500 to-green-600 text-white'
                : 'bg-slate-200 text-slate-600'
          }`}>
            {index + 1}
          </div>
          {index < 4 && (
            <div className="w-0.5 h-12 bg-gradient-to-b from-slate-200 to-slate-300 my-2" />
          )}
        </div>
        <span className={`ml-4 mt-2 font-semibold transition-colors duration-300 ${
          currentStep === step ? 'text-blue-600' : 'text-slate-600'
        }`}>
          {step === 'exam_selection' ? 'Select Exams' : step.charAt(0).toUpperCase() + step.slice(1)}
        </span>
      </div>
    ))}
  </div>
</div>
          {/* Main Content */}
          <div className="w-full">
            {currentStep === 'upload' && (
              <div className="w-full  backdrop-blur-sm rounded-3xl border border-white/20 px-8 animate-fade-in">
               
                <div className="space-y-6">
                  <div>
                    <label className="block  font-semibold text-slate-700 mb-3">
                      Result Name
                    </label>
                    <input
                      type="text"
                      value={templateName}
                      onChange={(e) => setTemplateName(e.target.value)}
                      className="w-full px-4 py-3 border border-slate-200 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200 bg-white/50 backdrop-blur-sm"
                      placeholder="Enter template name (e.g., Senior Class Results)"
                    />
                  </div>

                  <div>
                    <label className="block  font-semibold text-slate-700 mb-3">
                      DOCX Template File
                    </label>
                    <div className="border-2 border-dashed border-slate-300 rounded p-8 text-center bg-gradient-to-br from-slate-50 to-blue-50 hover:from-blue-50 hover:to-indigo-50 transition-all duration-300">
                      <input
                        type="file"
                        accept=".docx"
                        onChange={handleFileUpload}
                        className="hidden"
                        id="file-upload"
                      />
                      <label htmlFor="file-upload" className="cursor-pointer">
                        <div className="w-16 h-16 bg-gradient-to-r from-blue-500 to-blue-600 rounded-full flex items-center justify-center mx-auto mb-4">
                          <Upload className="w-8 h-8 text-white" />
                        </div>
                        <p className=" font-medium text-slate-700">
                          {uploadedFile ? uploadedFile.name : 'Click to upload DOCX template file'}
                        </p>
                        <p className=" text-slate-500 mt-2">
                          Upload a DOCX file with empty table cells that you want to fill with student results
                        </p>
                      </label>
                    </div>
                  </div>

                  {/* DOCX Preview */}
                  {docxPreview && (
                    <div className="mt-6 p-6 bg-gradient-to-br from-slate-50 to-blue-50 rounded-3xl border border-slate-200">
                      <h3 className="font-bold text-slate-800 mb-4 flex items-center gap-3">
                        <div className="w-8 h-8 bg-gradient-to-r from-green-500 to-green-600 rounded-full flex items-center justify-center">
                          <FileText className="w-4 h-4 text-white" />
                        </div>
                        Template Preview: {docxPreview.fileName}
                      </h3>
                      <div className="grid grid-cols-2 gap-6  text-slate-600 mb-4">
                        <div className="flex items-center gap-2">
                          <span>Tables found:</span>
                          <span className="font-bold text-blue-600">{docxPreview.totalTables || 0}</span>
                        </div>
                        <div className="flex items-center gap-2">
                          <span>Mappable cells:</span>
                          <span className="font-bold text-green-600">{docxPreview.totalMappableCells || 0}</span>
                        </div>
                      </div>
                      
                      {/* Show all tables preview */}
                      {tableStructure.length > 0 && (
                        <div className="space-y-6">
                          {tableStructure.map((table: any, tableIndex: number) => (
                            <div key={table.id} className="border border-slate-200 rounded-2xl overflow-hidden bg-white/50 backdrop-blur-sm">
                              <div className="bg-gradient-to-r from-slate-100 to-blue-100 px-4 py-3  font-bold flex items-center justify-between">
                                <span className="text-slate-800">{table.name}</span>
                                <span className=" text-slate-600 bg-white/50 px-3 py-1 rounded-full">
                                  {table.rows.reduce((total: number, row: any) => 
                                    total + row.cells.filter((cell: any) => cell.mappable).length, 0)} empty cells
                                </span>
                              </div>
                              <div className="p-4 max-h-48 overflow-auto">
                                <table className="w-full  border-collapse">
                                  {table.rows.slice(0, 5).map((row: any, rowIndex: number) => (
                                    <tr key={row.id}>
                                      {row.cells.map((cell: any, cellIndex: number) => (
                                        <td 
                                          key={cell.id}
                                          className={`border border-slate-300 px-3 py-2 ${
                                            cell.type === 'header' 
                                              ? 'bg-gradient-to-r from-slate-100 to-blue-100 font-bold text-slate-800' 
                                              : cell.mappable 
                                                ? 'bg-gradient-to-r from-yellow-50 to-amber-50 border-dashed border-yellow-300' 
                                                : 'bg-white'
                                          }`}
                                        >
                                          {cell.content === '[Empty]' ? (
                                            <span className="text-amber-600  italic font-medium">Empty Cell</span>
                                          ) : (
                                            cell.content
                                          )}
                                        </td>
                                      ))}
                                    </tr>
                                  ))}
                                </table>
                                {table.rows.length > 5 && (
                                  <p className=" text-slate-500 mt-3 text-center font-medium">
                                    ... and {table.rows.length - 5} more rows
                                  </p>
                                )}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                      
                      {tableStructure.length === 0 && (
                        <div className="text-center py-8">
                          <div className="w-16 h-16 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full flex items-center justify-center mx-auto mb-4">
                            <AlertCircle className="w-8 h-8 text-white" />
                          </div>
                          <p className=" font-medium text-slate-600 mb-2">No tables found in the DOCX file</p>
                          <p className=" text-slate-500">Make sure your DOCX contains tables with empty cells</p>
                        </div>
                      )}
                    </div>
                  )}

                  <button
                    onClick={createTemplate}
                    disabled={!templateName.trim() || !uploadedFile || !docxPreview}
                    className="w-full px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                  >
                    Create Template & Continue to Exam Selection
                  </button>
                </div>
              </div>
            )}

            {/* Step 2: Select Exams to Include */}
            {currentStep === 'exam_selection' && (
              <div className=" backdrop-blur-sm rounded-3xl border border-white/20 px-8  animate-fade-in">
              

                <div className=" text-amber-500 italic border-blue-200/50 rounded-md px-4 py-2 mb-8">
                  <p className="">
                    Select which exams to include in the result compilation. You can merge results from multiple exams for each student.
                  </p>
                </div>

                {availableExams.length > 0 ? (
                  <div className="space-y-6">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                      {availableExams.map((exam) => (
                        <div key={exam.examId} className="border border-slate-200 rounded-md p-6 bg-white/50 backdrop-blur-sm hover: transition-all duration-300">
                          <label className="flex items-start gap-4 cursor-pointer">
                            <input
                              type="checkbox"
                              checked={selectedExams.includes(exam.examId)}
                              onChange={(e) => {
                                if (e.target.checked) {
                                  setSelectedExams([...selectedExams, exam.examId])
                                } else {
                                  setSelectedExams(selectedExams.filter(id => id !== exam.examId))
                                }
                              }}
                              className="mt-1 w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                            />
                            <div className="flex-1">
                              <div className="font-bold text-slate-800 ">{exam.examName}</div>
                              <div className=" text-slate-600 mt-1">
                                Type: <span className="font-semibold text-blue-600">{exam.examType}</span>
                              </div>
                              {exam.term && (
                                <div className=" text-slate-600">
                                  Term: <span className="font-semibold text-green-600">{exam.term}</span>
                                </div>
                              )}
                              {exam.session && (
                                <div className=" text-slate-600">
                                  Session: <span className="font-semibold text-purple-600">{exam.session}</span>
                                </div>
                              )}
                              <div className=" text-slate-500 mt-2 bg-slate-100 px-2 py-1 rounded-full inline-block">
                                ID: {exam.examId}
                              </div>
                            </div>
                          </label>
                        </div>
                      ))}
                    </div>

                    <div className="flex gap-4 mt-8">
                      <button
                        onClick={() => setCurrentStep('upload')}
                        className="px-4 py-2 border border-slate-300 text-slate-700 rounded-full hover:bg-slate-50 transition-all duration-300 font-medium"
                      >
                        Back
                      </button>
                      <button
                        onClick={() => {
                          if (selectedExams.length === 0) {
                            setError('Please select at least one exam')
                            return
                          }
                          setCurrentStep('mapping')
                        }}
                        className="px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                      >
                        Continue to Mapping ({selectedExams.length} exams selected)
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="text-center py-12">
                    <div className="w-16 h-16 bg-gradient-to-r from-slate-400 to-slate-500 rounded-full flex items-center justify-center mx-auto mb-4">
                      <FileText className="w-8 h-8 text-white" />
                    </div>
                    <p className="text-slate-600 mb-2 font-medium">No exams found in the result data.</p>
                    <p className=" text-slate-500 mb-6">
                      You can still proceed to mapping using the general subject scores.
                    </p>
                    <div className="flex gap-4 justify-center">
                      <button
                        onClick={() => setCurrentStep('upload')}
                        className="px-4 py-2 border border-slate-300 text-slate-700 rounded-full hover:bg-slate-50 transition-all duration-300 font-medium"
                      >
                        Back
                      </button>
                      <button
                        onClick={() => setCurrentStep('mapping')}
                        className="px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                      >
                        Continue to Mapping
                      </button>
                    </div>
                  </div>
                )}
              </div>
            )}

            {currentStep === 'mapping' && selectedTemplate && (
              <div className=" px-8  animate-fade-in">
             
                <div className="space-y-6">
                  <div className="flex items-center justify-between">
                    <div>
                      <p className=" text-slate-600">
                        Template: <span className="font-bold text-blue-600">{selectedTemplate.name}</span>
                      </p>
                      <p className=" text-slate-500 mt-1">
                        Click on empty cells below to map them to subjects
                      </p>
                    </div>
                    <div className=" text-slate-500 bg-slate-100 px-3 py-2 rounded-full">
                      {mappings.length} mappings created
                    </div>
                  </div>

                  {/* Interactive Tables for Mapping */}
                  {tableStructure.length > 0 && (
                    <div className="space-y-6">
                      {tableStructure.map((table: any, tableIndex: number) => (
                        <div key={table.id} className="border border-slate-200 rounded overflow-hidden bg-white/50 backdrop-blur-sm">
                          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 px-4 py-2  font-bold text-blue-900 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                              <div className="w-8 h-8 bg-gradient-to-r from-blue-500 to-blue-600 rounded-full flex items-center justify-center">
                                <Table className="w-4 h-4 text-white" />
                              </div>
                              {table.name} - Click empty cells to map subjects
                            </div>
                            <span className=" bg-blue-100 px-3 py-1 rounded-full">
                              {table.rows.reduce((total: number, row: any) => 
                                total + row.cells.filter((cell: any) => cell.mappable).length, 0)} mappable cells
                            </span>
                          </div>
                          <div className="p-6 max-h-96 overflow-auto">
                            <table className="w-full border-collapse ">
                              {table.rows.map((row: any, rowIndex: number) => (
                                <tr key={row.id}>
                                  {row.cells.map((cell: any, cellIndex: number) => {
                                    const isHeader = cell.type === 'header'
                                    const isMappable = cell.mappable && !isHeader
                                    const isMapped = mappings.some(m => m.cellId === cell.id)
                                    const isSelected = selectedCell === cell.id
                                    const mapping = mappings.find(m => m.cellId === cell.id)
                                    
                                    return (
                                      <td 
                                        key={cell.id}
                                        onClick={() => {
                                          const isMapped = mappings.some(m => m.cellId === cell.id)
                                          if (!isMapped) {
                                            handleCellClick(
                                              cell.id, 
                                              table.name,
                                              cell.tableIndex,
                                              cell.rowIndex,
                                              cell.cellIndex
                                            )
                                          }
                                        }}
                                        className={`border border-slate-300 px-4 py-3 transition-all duration-300 ${
                                          isHeader 
                                            ? 'bg-gradient-to-r from-slate-100 to-blue-100 font-bold text-slate-900' 
                                            : isMapped
                                              ? 'bg-gradient-to-r from-green-100 to-emerald-100 border-green-300 text-green-800'
                                              : isMappable
                                                ? 'bg-gradient-to-r from-yellow-50 to-amber-50 hover:from-blue-50 hover:to-indigo-50 cursor-pointer border-dashed border-yellow-300 hover:border-blue-400 transform hover:scale-105'
                                                : 'bg-slate-50 text-slate-600'
                                        } ${
                                          !isMapped ? 'cursor-pointer hover:shadow-lg' : ''
                                        } ${
                                          isSelected ? 'ring-2 ring-blue-500 bg-gradient-to-r from-blue-100 to-indigo-100 animate-pulse-glow' : ''
                                        }`}
                                        title={!isMapped ? 'Click to map this cell to data' : `Mapped to ${mapping?.format === 'student_id' ? 'Student ID' : mapping?.format === 'class_name' ? 'Class Name' : mapping?.subject}`}
                                      >
                                        {isMapped ? (
                                          <div className="text-center">
                                            <div className="font-bold">
                                              {mapping?.format === 'student_name' ? 'Student Name' :
                                               mapping?.format === 'student_id' ? 'Student ID' :
                                               mapping?.format === 'class_name' ? 'Class Name' :
                                               mapping?.subject || mapping?.format}
                                            </div>
                                            <div className=" text-green-600 bg-green-50 px-2 py-1 rounded-full mt-1 inline-block">
                                              {mapping?.format}
                                            </div>
                                          </div>
                                        ) : isMappable ? (
                                          <div className="text-center text-amber-600">
                                            <div className="w-6 h-6 bg-gradient-to-r from-amber-400 to-yellow-500 rounded-full flex items-center justify-center mx-auto mb-2">
                                              <MapPin className="w-3 h-3 text-white" />
                                            </div>
                                            <span className=" font-medium">Click to map</span>
                                          </div>
                                        ) : isHeader ? (
                                          <div className="text-center">
                                            {cell.content === '[Empty]' ? (
                                              <div className="text-blue-600 cursor-pointer hover:text-blue-800 transition-colors duration-200">
                                                <div className="w-6 h-6 bg-gradient-to-r from-blue-400 to-blue-500 rounded-full flex items-center justify-center mx-auto mb-2">
                                                  <MapPin className="w-3 h-3 text-white" />
                                                </div>
                                                <span className=" font-medium">Click to map</span>
                                              </div>
                                            ) : (
                                              cell.content
                                            )}
                                          </div>
                                        ) : (
                                          cell.content === '[Empty]' ? '' : cell.content
                                        )}
                                      </td>
                                    )
                                  })}
                                </tr>
                              ))}
                            </table>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}

                  {/* Current Mappings List */}
                  {mappings.length > 0 && (
                    <div className="mt-8">
                      <h3 className="font-bold text-slate-800 mb-4">Current Mappings</h3>
                      <div className="space-y-3">
                        {mappings.map((mapping, index) => (
                          <div key={index} className="flex items-center justify-between px-4 py-2 bg-gradient-to-r from-slate-50 to-blue-50 rounded border border-slate-200">
                            <div className="flex items-center gap-4">
                              <span className="font-bold text-blue-600 ">
                                {mapping.format === 'student_name' ? 'Student Name' :
                                 mapping.format === 'student_id' ? 'Student ID' :
                                 mapping.format === 'class_name' ? 'Class Name' :
                                 mapping.subject || mapping.format}
                              </span>
                              {mapping.examTerm && (
                                <span className=" bg-gradient-to-r from-purple-100 to-purple-200 text-purple-800 px-3 py-1 rounded-full font-medium">
                                  {mapping.examTerm.replace('_', ' ').toUpperCase()}
                                </span>
                              )}
                              <span className=" text-slate-600 bg-slate-100 px-2 py-1 rounded-full">
                                Cell: {mapping.cellId}
                              </span>
                              <span className=" bg-gradient-to-r from-blue-100 to-blue-200 text-blue-800 px-3 py-1 rounded-full font-medium">
                                {mapping.format}
                              </span>
                              {mapping.calculationType && (
                                <span className=" bg-gradient-to-r from-green-100 to-green-200 text-green-800 px-3 py-1 rounded-full font-medium">
                                  {mapping.calculationType}
                                </span>
                              )}
                            </div>
                            <button
                              onClick={() => {
                                setMappings(mappings.filter((_, i) => i !== index))
                                setSuccess('Mapping removed')
                              }}
                              className="text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-50 transition-all duration-200"
                            >
                              <Trash2 className="w-4 h-4" />
                            </button>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {mappings.length > 0 && (
                    <button
                      onClick={saveMappings}
                      className="w-full px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                    >
                      Save Mappings & Continue to Preview
                    </button>
                  )}
                </div>
              </div>
            )}

            {currentStep === 'preview' && selectedTemplate && (
              <div className=" backdrop-blur-sm rounded-3xl border border-white/20 px-8 animate-fade-in">
              
                
                <div className="bg-gradient-to-r from-yellow-50 to-amber-50 border border-yellow-200/50 rounded-2xl p-6 mb-8">
                  <p className="text-yellow-800  font-medium">
                    <strong>Manual Input & Data Integration:</strong> 
                    <br /> CT and Exam columns have input boxes for manual score entry
                    <br /> Total columns automatically calculate CT + Exam scores
                    <br /> Student IDs are populated from user_email (API data)
                    <br /> Class Names are populated from classname (API data)
                    <br /> Other manual input fields can be used for additional scores
                  </p>
                </div>
                
                <div className="hidden overflow-x-auto bg-white/50 backdrop-blur-sm rounded-2xl border border-slate-200">
                  <table className="w-full ">
                    <thead>
                      <tr className="border-b border-slate-200 bg-gradient-to-r from-slate-100 to-blue-100">
                        <th className="text-left p-4 font-bold text-slate-800">Student</th>
                        {selectedTemplate.mappings.map((mapping, index) => (
                          <th key={index} className="text-left p-4 font-bold text-slate-800">
                            <div>
                              {mapping.format === 'student_name' ? 'Student Name' :
                               mapping.format === 'student_id' ? 'Student ID' :
                               mapping.format === 'class_name' ? 'Class' :
                               mapping.format === 'ct_score' ? `${mapping.subject} (CT)` :
                               mapping.format === 'exam_score' ? `${mapping.subject} (Exam)` :
                               mapping.format === 'ct_exam_total' ? `${mapping.subject} (Total)` :
                               mapping.subject}
                            </div>
                            {mapping.examName && (
                              <span className=" text-blue-600 font-normal">
                                ({mapping.examName})
                              </span>
                            )}
                            {mapping.examTerm && (
                              <span className=" text-purple-600 font-normal">
                                ({mapping.examTerm.replace('_', ' ')})
                              </span>
                            )}
                            {mapping.calculationType && (
                              <span className=" text-green-600 font-normal">
                                ({mapping.calculationType})
                              </span>
                            )}
                            <div className=" text-slate-500 font-normal mt-1">
                              ({mapping.format === 'manual_input' ? 'Manual' : 
                                mapping.format === 'ct_score' ? 'CT Input' :
                                mapping.format === 'exam_score' ? 'Exam Input' :
                                mapping.format === 'ct_exam_total' ? 'Auto-Total' :
                                mapping.format})
                            </div>
                          </th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {results.map((result, index) => (
                        <tr key={index} className="border-b border-slate-100 hover:bg-slate-50/50 transition-colors duration-200">
                          <td className="p-4 font-bold text-slate-800">{result.username}</td>
                          {selectedTemplate.mappings.map((mapping, mapIndex) => {
                            // Handle CT score manual input
                            if (mapping.format === 'ct_score') {
                              const ctKey = `${result.username}_${mapping.subject}`
                              return (
                                <td key={mapIndex} className="p-4">
                                  <input
                                    type="number"
                                    placeholder="CT Score"
                                    value={manualCTScores[ctKey]?.[mapping.subject!] || ''}
                                    onChange={(e) => {
                                      const value = e.target.value
                                      setManualCTScores(prev => ({
                                        ...prev,
                                        [ctKey]: {
                                          ...prev[ctKey],
                                          [mapping.subject!]: value ? parseFloat(value) : 0
                                        }
                                      }))
                                    }}
                                    className="w-20 px-3 py-2 border border-slate-300 rounded-xl text-center focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200 "
                                  />
                                </td>
                              )
                            }
                            
                            // Handle Exam score manual input
                            if (mapping.format === 'exam_score') {
                              const examKey = `${result.username}_${mapping.subject}`
                              return (
                                <td key={mapIndex} className="p-4">
                                  <input
                                    type="number"
                                    placeholder="Exam Score"
                                    value={manualExamScores[examKey]?.[mapping.subject!] || ''}
                                    onChange={(e) => {
                                      const value = e.target.value
                                      setManualExamScores(prev => ({
                                        ...prev,
                                        [examKey]: {
                                          ...prev[examKey],
                                          [mapping.subject!]: value ? parseFloat(value) : 0
                                        }
                                      }))
                                    }}
                                    className="w-20 px-3 py-2 border border-slate-300 rounded-xl text-center focus:ring-2 focus:ring-green-500 focus:border-green-500 transition-all duration-200 "
                                  />
                                </td>
                              )
                            }
                            
                            // Handle manual input fields (other types)
                            if (mapping.format === 'manual_input') {
                              const manualKey = `${result.username}_${mapping.subject}`
                              return (
                                <td key={mapIndex} className="p-4">
                                  <input
                                    type="number"
                                    placeholder="Enter score"
                                    value={manualScores[manualKey]?.[mapping.subject!] || ''}
                                    onChange={(e) => {
                                      const value = e.target.value
                                      setManualScores(prev => ({
                                        ...prev,
                                        [manualKey]: {
                                          ...prev[manualKey],
                                          [mapping.subject!]: value ? parseFloat(value) : 0
                                        }
                                      }))
                                    }}
                                    className="w-20 px-3 py-2 border border-slate-300 rounded-xl text-center focus:ring-2 focus:ring-yellow-500 focus:border-yellow-500 transition-all duration-200 "
                                  />
                                </td>
                              )
                            }
                            
                            // Use the enhanced getStudentValue function for other formats
                            const value = getStudentValue(result, mapping)
                            
                            return (
                              <td key={mapIndex} className="p-4 text-slate-700 font-medium">
                                {value}
                              </td>
                            )
                          })}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>

                <div className="mt-8 flex gap-4">
                  <button
                    onClick={() => setCurrentStep('export')}
                    className="px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                  >
                    Continue to Export
                  </button>
                  <button
                    onClick={() => setCurrentStep('mapping')}
                    className="px-4 py-2 border border-slate-300 text-slate-700 rounded-full hover:bg-slate-50 transition-all duration-300 font-medium"
                  >
                    Edit Mappings
                  </button>
                </div>
              </div>
            )}

            {currentStep === 'export' && selectedTemplate && (
              <div className=" backdrop-blur-sm rounded-3xl border border-white/20 p-8 animate-fade-in">
           
                
                <div className="space-y-6">
                  <div className="p-6 bg-gradient-to-r from-blue-50 to-indigo-50 rounded border border-blue-200/50">
                    <h3 className="font-bold text-blue-900  mb-3">Ready to Export</h3>
                    <div className="hidden space-y-2  text-blue-700">
                      <p><span className="font-semibold">Template:</span> {selectedTemplate.name}</p>
                      <p><span className="font-semibold">Students:</span> {results.length}</p>
                      <p><span className="font-semibold">Mapped Cells:</span> {selectedTemplate.mappings.length}</p>
                    </div>
                    <p className=" text-blue-600 mt-4 font-medium">
                      This will generate individual DOCX files for each student with their results filled in
                    </p>
                  </div>

                  <button
                    onClick={generateDocument}
                    disabled={loading}
                    className="w-full px-4 py-2 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-full hover:from-green-600 hover:to-green-700 disabled:opacity-50 flex items-center justify-center gap-3 transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                  >
                    <Download className={`w-4 h-4 ${loading ? 'animate-pulse' : ''}`} />
                    {loading ? 'Generating DOCX Files...' : 'Generate Individual DOCX Files'}
                  </button>
                </div>
              </div>
            )}
          </div>

        </div>

        {/* Mapping Modal */}
        {showMappingModal && selectedCell && (
          <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 animate-fade-in">
            <div className="bg-white/95 backdrop-blur-sm rounded p-8 w-full max-w-2xl max-h-[90vh] overflow-y-auto border border-white/20">
              <h3 className=" font-bold text-slate-800 mb-6">Map Cell to Data</h3>
              
              <div className="mb-6 p-4 bg-gradient-to-r from-slate-50 to-blue-50 rounded-2xl border border-slate-200">
                <p className=" text-slate-600">
                  Selected Cell: <span className="font-bold text-blue-600">{selectedCell}</span>
                </p>
              </div>
              
              <div className="space-y-6">
                <div>
                  <label className="block  font-bold text-slate-700 mb-3">
                    Data Type
                  </label>
                  <select
                    value={currentMapping.format || ''}
                    onChange={(e) => setCurrentMapping({...currentMapping, format: e.target.value as any})}
                    className="w-full px-4 py-3 border border-slate-300 rounded-2xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200  "
                  >
                    <option value="">Select data type</option>
                    <option value="student_name">Student Name (from username)</option>
                    <option value="student_id">Student ID (from user_email)</option>
                    <option value="class_name">Class Name (from classname)</option>
                    <option value="percentage">Subject Score - Percentage (85%)</option>
                    <option value="raw">Subject Score - Raw (17/20)</option>
                    <option value="total">Subject Score - Total (17)</option>
                    <option value="grade">Subject Score - Grade (A, B, C)</option>
                    <option value="ct_score">CT Score (Manual Input)</option>
                    <option value="exam_score">Exam Score (Manual Input)</option>
                    <option value="ct_exam_total">CT + Exam Total (Auto-calculated)</option>
                    <option value="calculated">Calculated (CT + Exam + Total)</option>
                    <option value="manual_input">Manual Input (Other)</option>
                  </select>
                </div>

                {/* Subject Selection - only show for subject-related formats */}
                {['percentage', 'raw', 'total', 'grade', 'calculated', 'manual_input', 'ct_score', 'exam_score', 'ct_exam_total'].includes(currentMapping.format || '') && (
                  <div>
                    <label className="block  font-bold text-slate-700 mb-3">
                      Subject
                    </label>
                    <select
                      value={currentMapping.subject || ''}
                      onChange={(e) => setCurrentMapping({...currentMapping, subject: e.target.value})}
                      className="w-full px-4 py-3 border border-slate-300 rounded-2xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200  "
                    >
                      <option value="">Select subject</option>
                      {availableSubjects.map((subject) => (
                        <option key={subject} value={subject}>{subject}</option>
                      ))}
                    </select>
                  </div>
                )}

                {/* Exam Selection - show for score-related formats */}
                {['percentage', 'raw', 'total', 'grade'].includes(currentMapping.format || '') && (
                  <div>
                    <label className="block  font-bold text-slate-700 mb-3">
                      Specific Exam (Optional)
                    </label>
                    <select
                      value={currentMapping.examName || ''}
                      onChange={(e) => {
                        const selectedExam = availableExams.find(exam => exam.examName === e.target.value)
                        setCurrentMapping({
                          ...currentMapping, 
                          examName: e.target.value,
                          examId: selectedExam?.examId,
                          examType: selectedExam?.examType
                        })
                      }}
                      className="w-full px-4 py-3 border border-slate-300 rounded-2xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200  "
                    >
                      <option value="">Use All Results (Combined)</option>
                      {availableExams.map((exam) => (
                        <option key={exam.examId} value={exam.examName}>
                          {exam.examName}
                        </option>
                      ))}
                    </select>
                    <p className=" text-slate-500 mt-2">
                      Select specific exam or leave blank for combined results from all exams
                    </p>
                  </div>
                )}

                {/* Calculation Options - enhanced for CT + Exam + Total */}
                {currentMapping.format === 'calculated' && (
                  <>
                    <div>
                      <label className="block  font-bold text-slate-700 mb-3">
                        Calculation Type
                      </label>
                      <select
                        value={currentMapping.calculationType || ''}
                        onChange={(e) => setCurrentMapping({...currentMapping, calculationType: e.target.value as any})}
                        className="w-full px-4 py-3 border border-slate-300 rounded-2xl focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all duration-200  "
                      >
                        <option value="">Select calculation</option>
                        <option value="ct_exam_total">CT + Exam + Total (Auto-calculated)</option>
                        <option value="sum">Sum of Selected Exams</option>
                        <option value="average">Average of Selected Exams</option>
                      </select>
                    </div>

                    {currentMapping.calculationType === 'ct_exam_total' && (
                      <div className="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl border border-blue-200">
                        <p className=" text-blue-800 font-medium">
                          <strong>Auto-calculation:</strong> This will automatically calculate CT + Exam + Total scores for the selected subject.
                        </p>
                      </div>
                    )}

                    {['sum', 'average'].includes(currentMapping.calculationType || '') && (
                      <div>
                        <label className="block  font-bold text-slate-700 mb-3">
                          Source Exams for Calculation
                        </label>
                        <div className="space-y-3 max-h-40 overflow-y-auto bg-slate-50 rounded-2xl p-4">
                          {availableExams.map((exam) => (
                            <label key={exam.examId} className="flex items-center cursor-pointer">
                              <input
                                type="checkbox"
                                checked={currentMapping.calculationSources?.includes(exam.examName) || false}
                                onChange={(e) => {
                                  const sources = currentMapping.calculationSources || []
                                  if (e.target.checked) {
                                    setCurrentMapping({
                                      ...currentMapping,
                                      calculationSources: [...sources, exam.examName]
                                    })
                                  } else {
                                    setCurrentMapping({
                                      ...currentMapping,
                                      calculationSources: sources.filter(s => s !== exam.examName)
                                    })
                                  }
                                }}
                                className="mr-3 w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                              />
                              <span className=" font-medium text-slate-700">{exam.examName}</span>
                            </label>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                )}

                {/* Info boxes for different formats */}
                {currentMapping.format === 'student_name' && (
                  <div className="p-4 bg-gradient-to-r from-green-50 to-emerald-50 rounded-2xl border border-green-200">
                    <p className=" text-green-800 font-medium">
                      <strong>Student Name:</strong> This cell will be filled with the username from your API data for each student.
                    </p>
                  </div>
                )}

                {currentMapping.format === 'student_id' && (
                  <div className="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-2xl border border-blue-200">
                    <p className=" text-blue-800 font-medium">
                      <strong>Student ID:</strong> This cell will be filled with the user_email from your API data for each student.
                    </p>
                  </div>
                )}

                {currentMapping.format === 'class_name' && (
                  <div className="p-4 bg-gradient-to-r from-indigo-50 to-purple-50 rounded-2xl border border-indigo-200">
                    <p className=" text-indigo-800 font-medium">
                      <strong>Class Name:</strong> This cell will be filled with the classname from your API data for each student.
                    </p>
                  </div>
                )}

                {currentMapping.format === 'ct_score' && (
                  <div className="p-4 bg-gradient-to-r from-blue-50 to-cyan-50 rounded-2xl border border-blue-200">
                    <p className=" text-blue-800 font-medium">
                      <strong>CT Score:</strong> This cell will have an input box for manual CT (Continuous Assessment) score entry.
                    </p>
                  </div>
                )}

                {currentMapping.format === 'exam_score' && (
                  <div className="p-4 bg-gradient-to-r from-green-50 to-teal-50 rounded-2xl border border-green-200">
                    <p className=" text-green-800 font-medium">
                      <strong>Exam Score:</strong> This cell will have an input box for manual Exam score entry.
                    </p>
                  </div>
                )}

                {currentMapping.format === 'ct_exam_total' && (
                  <div className="p-4 bg-gradient-to-r from-purple-50 to-pink-50 rounded-2xl border border-purple-200">
                    <p className=" text-purple-800 font-medium">
                      <strong>CT + Exam Total:</strong> This cell will automatically calculate the sum of CT and Exam scores for the selected subject.
                    </p>
                  </div>
                )}

                {currentMapping.format === 'manual_input' && (
                  <div className="p-4 bg-gradient-to-r from-yellow-50 to-amber-50 rounded-2xl border border-yellow-200">
                    <p className=" text-yellow-800 font-medium">
                      <strong>Manual Input:</strong> This cell will have an input box in the preview for manual score entry.
                    </p>
                  </div>
                )}
              </div>

              <div className="flex gap-4 mt-8">
                <button
                  onClick={addMapping}
                  className="flex-1 px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-full hover:from-blue-600 hover:to-blue-700 transition-all duration-300 transform hover:scale-105 active:scale-95 font-semibold"
                >
                  Map to Cell
                </button>
                <button
                  onClick={() => {
                    setShowMappingModal(false)
                    setCurrentMapping({})
                    setSelectedCell(null)
                  }}
                  className="flex-1 px-4 py-2 border border-slate-300 text-slate-700 rounded-full hover:bg-slate-50 transition-all duration-300 font-medium"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}